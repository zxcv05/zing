//! Functions for Connecting to Interfaces.

const std = @import("std");
const fs = std.fs;
const fmt = std.fmt;
const log = std.log;
const mem = std.mem;
const meta = std.meta;
const net = std.net;
const os = std.os;
const posix = std.posix;
const process = std.process;
const time = std.time;

const lib = @import("zinglib.zig");
const consts = lib.constants;
const Addresses = lib.Addresses;
const Datagrams = lib.Datagrams;

/// A Socket to an Interface.
pub const IFSocket = struct {
    /// Socket Descriptor.
    desc: posix.socket_t,
    /// Interface Name.
    if_name: []const u8,
    /// Interface Hardware Family.
    hw_fam: u16,

    /// Config for Initializing an Interface Socket.
    pub const IFSocketInitConfig = struct {
        /// Interface Name.
        if_name: []const u8 = "eth0",
        /// Interface MAC Address.
        if_mac_addr: ?[]const u8 = null,
    };

    /// Create a Socket Connection to an Interface (`if_name`).
    pub fn init(config: IFSocketInitConfig) !@This() {
        // Setup Socket
        const if_sock = posix.socket(os.linux.AF.PACKET, os.linux.SOCK.RAW, consts.ETH_P_ALL) catch {
            log.err("There was an error connecting to the Interface. You may need to run with root privileges.", .{});
            return error.CouldNotConnectToInterface;
        };
        var if_name_ary: [16]u8 = .{0} ** 16;
        const if_name_len = @min(16, config.if_name.len);
        @memcpy(if_name_ary[0..if_name_len], config.if_name[0..if_name_len]);

        // - Interface Request
        var if_req = mem.zeroes(posix.ifreq);
        if_req.ifrn.name = if_name_ary;

        // - Request Interface Family
        const ioctl_num = os.linux.ioctl(if_sock, consts.SIOCGIFHWADDR, @intFromPtr(&if_req));
        if (ioctl_num != 0) {
            log.err("There was an issue getting the Hardware info for Interface '{s}': '{d}'.", .{ config.if_name, ioctl_num });
            return error.CouldNotGetInterfaceInfo;
        }
        const hw_fam = if_req.ifru.hwaddr.family;

        // - Interface Address
        var if_addr = posix.sockaddr.ll{
            .family = os.linux.AF.PACKET,
            .protocol = consts.ETH_P_ALL,
            .pkttype = consts.PACKET_HOST,
            .halen = 6,
            .hatype = hw_fam,
            .addr = if (config.if_mac_addr) |mac| customMAC: {
                if (mac.len > 8) return error.CustomMACTooLong;
                // 8-byte MAC Formatted for `os.sockaddr.ll`
                if (mac.len == 8) break :customMAC mac[0..8].*;
                // 6-byte normal MAC
                var custom_mac: [8]u8 = .{0x0} ** 8;
                for (custom_mac[0..(mac.len)], mac) |*c, m| c.* = m;
                break :customMAC custom_mac;
            } else if_req.ifru.hwaddr.data[0..8].*,
            .ifindex = ifIdx: {
                // Request Interface Index
                try posix.ioctl_SIOCGIFINDEX(if_sock, &if_req);
                break :ifIdx if_req.ifru.ivalue;
            },
        };

        // - Bind to Socket
        posix.bind(if_sock, @as(*os.linux.sockaddr, @ptrCast(&if_addr)), @sizeOf(@TypeOf(if_addr))) catch return error.CouldNotConnectToInterface;

        return .{
            .desc = if_sock,
            .if_name = config.if_name,
            .hw_fam = hw_fam,
        };
    }

    /// Close this Interface Socket.
    pub fn close(self: *const @This()) void {
        posix.close(self.desc);
    }

    /// Get the MAC Address of this Interface if it has one.
    pub fn getMAC(self: *const @This()) !Addresses.MAC {
        var if_name_ary: [16]u8 = .{0} ** 16;
        const if_name_len = @min(16, self.if_name.len);
        @memcpy(if_name_ary[0..if_name_len], self.if_name[0..if_name_len]);
        var if_req = mem.zeroes(posix.ifreq);
        if_req.ifrn.name = if_name_ary;
        const ioctl_num = os.linux.ioctl(self.desc, consts.SIOCGIFHWADDR, @intFromPtr(&if_req));
        if (ioctl_num != 0) {
            log.err("There was an issue getting the Hardware info for Interface '{s}': '{d}'.", .{ self.if_name, ioctl_num });
            return error.CouldNotGetInterfaceInfo;
        }
        return @bitCast(if_req.ifru.hwaddr.data[0..6].*);
    }

    /// Get the IPv4 Address of this Interface if it has one.
    pub fn getIPv4(self: *const @This()) !Addresses.IPv4 {
        const inet_sock = try posix.socket(os.linux.AF.INET, os.linux.SOCK.DGRAM, 0);
        defer posix.close(inet_sock);
        var if_name_ary: [16]u8 = .{0} ** 16;
        const if_name_len = @min(16, self.if_name.len);
        @memcpy(if_name_ary[0..if_name_len], self.if_name[0..if_name_len]);
        var if_req = mem.zeroes(posix.ifreq);
        if_req.ifrn.name = if_name_ary;
        const ioctl_num = os.linux.ioctl(inet_sock, consts.SIOCGIFADDR, @intFromPtr(&if_req));
        if (ioctl_num != 0) {
            log.err("There was an issue getting the IP Address info for Interface '{s}': '{d}'.", .{ self.if_name, ioctl_num });
            return error.CouldNotGetInterfaceInfo;
        }
        return @bitCast(@as(os.linux.sockaddr.in, @bitCast(if_req.ifru.addr)).addr);
    }

    /// Set Promiscuous Mode for this Interface Socket.
    pub fn setPromiscuous(self: *const @This()) !void {
        var ifr_flags = mem.zeroes(posix.ifreq);
        ifr_flags.ifrn.name = self.if_name[0..16].*;
        ifr_flags.ifru.flags.PROMISC = true;
        const set_prom = os.linux.ioctl(self.desc, consts.SIOCSIFFLAGS, @intFromPtr(&ifr_flags));
        if (set_prom != 0) {
            log.err("There was an issue opening the socket in Promiscuous Mode:\n{s}\n", .{@tagName(posix.errno(set_prom))});
            return error.CouldNotOpenPromiscuous;
        } else log.debug("Opened Promiscuous Mode!\n", .{});
        defer {
            ifr_flags.ifru.flags = .{ .PROMISC = true };
            _ = os.linux.ioctl(self.desc, consts.SIOCSIFFLAGS, @intFromPtr(&ifr_flags));
        }
    }
};
